pub fn wavelength_to_stimul(wavelength: f32) -> [f32;3] {
    const VALUES: &[&[f32]] = &[
        &[-42.926358, -210.656885, 207.388095], //a0
        &[-2.039680, -0.145807, -6.306562],     //a1
        &[75.971783, 386.731976, -393.710048],  //b1
        &[57.330821, 305.471058, -315.665060],  //a2
        &[6.573391, 5.021838, 19.291754],       //b2
        &[8.111103, 6.838622, 19.641474],       //a3
        &[-38.765649, -208.206234, 214.221157], //b3
        &[-21.448345, -118.489020, 121.858468], //a4
        &[-5.939747, -5.762587, -15.182074],    //b4
        &[-3.389620, -3.797355, -8.677406],     //a5
        &[9.588300, 55.180346, -56.759638],     //b5
        &[3.250756, 19.972851, -20.631872],     //a6
        &[1.441277, 1.899046, 3.693488],        //b6
        &[0.396600, 0.691341, 1.048302],        //a7
        &[-0.711392, -5.089181, 5.365662],      //b7
        &[-0.079354, -0.707069, 0.789878],      //a8
        &[-0.072980, -0.141993, -0.148036],     //b8
        &[-0.001655, 0.000589, 0.000236],       //s
    ];//see https://onlinelibrary.wiley.com/doi/full/10.1002/col.22879
    let theta_p = std::f32::consts::PI * ((wavelength / 360.0).log10() / (850.0 / 360.0f32).log10());
    let vec = [0, 1, 2]
        .iter()
        .map(|i| {
            let mut sum = VALUES[0][*i];
            for j in 1..=8 {
                sum += VALUES[j * 2 - 1][*i] * (j as f32 * theta_p).cos(); //aj
                sum += VALUES[j * 2][*i] * (j as f32 * theta_p).sin(); //bj
            }
            10.0f32.powf(sum)
        })
        .collect::<Vec<f32>>();
    [
        vec[0],
        vec[1],
        vec[2],
    ]
}